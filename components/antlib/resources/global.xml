<?xml version="1.0" encoding="utf-8"?>
<project name="global" default="help" basedir="." xmlns:ivy="antlib:org.apache.ivy.ant">
<!--
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#
# $Id$
#
# Copyright 2006 University of Dundee. All rights reserved.
# Use is subject to license terms supplied in LICENSE.txt
#
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Written by:  Josh Moore <josh.moore@gmx.de>
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  DOCUMENTATION:
  ==============================================================================
  Central ant script. It imports all other helper scripts and property
  files in the proper order, and in general can be imported from
  anywhere.

  global.xml will determine its own location and bootstrap all other
  definitions from there.

-->

        <tstamp>
          <format property="now" pattern="yyyyMMddHHmmss"/>
        </tstamp>

        <!-- Where to find things. It is assume that to have imported this
        file any build script will have had to define the import.dir variable-->
        <import file="${import.dir}/directories.xml"/>

        <!-- Define properties :
                The user's environment (env) overrides all other
                variables, then comes the user defined
                local.properties, then the controlled *.properties
                files.
        -->

        <property environment="env" />
        <property name="env.J" value="1"/>

        <property file="${root.dir}/etc/local.properties" />
        <property file="${root.dir}/etc/local.properties.example" />
        <property file="${root.dir}/etc/omero.properties" />
        <property file="${root.dir}/etc/hibernate.properties" />
        <property name="test.with.fail" value="true"/>
        <property name="classpath.file" value="classpath.xml"/>
        <property name="omero.resolver" value="omero-resolver"/>

        <!-- For these definitions to work properly, directories.xml must be imported-->
        <property name="deps.lib.dir" value="${target.dir}/libs"/>
        <property name="ivy.local.default.root" value="${omero.home}/lib/repository"/>
        <!-- These are default values. If you'd like to override, due so before import-->
        <property name="ivy.buildlist.ivyfilepath" value="ivy.xml"/>
        <property name="ivy.dep.file"              value="ivy.xml"/>

        <!-- Post-import properties -->
        <property name="sql.dir"  value="${omero.home}/sql/${omero.db.profile}/${omero.db.version}__${omero.db.patch}"/>
        <condition property="ice.home" value="${env.ICE_HOME}">
            <isset property="env.ICE_HOME"/>
        </condition>

        <!--
          The idea for this macro is taken from maven2. Use deps-buildlist
          to create deps.build.path if you do not have one specified.
        -->
        <macrodef name="iterate">
                <attribute name="inheritAll" default="false"/>
                <attribute name="inheritRefs" default="false"/>
                <attribute name="buildpathref" default="deps.build.path"/>
                <attribute name="target"/>
                <sequential>
                <subant verbose="on" buildpathref="@{buildpathref}" inheritAll="@{inheritAll}" inheritRefs="@{inheritRefs}" failonerror="true" target="@{target}">
                        <property name="multi.test.with.fail" value="${test.with.fail}"/>
                        <property name="multi.test.skip" value="${test.skip}"/>
                        <property name="multi.generate.skip" value="${generate.skip}"/>
                        <property name="multi.checks.skip" value="${checks.skip}"/>
                        <property name="multi.emma.enabled" value="${emma.enabled}"/>
                        <!-- Defaults set in dependencies.xml -->
                        <property name="ivy.buildlist.ivyfilepath" value="${ivy.buildlist.ivyfilepath}"/>
                        <property name="ivy.dep.file" value="${ivy.dep.file}"/>
                        <propertyset>
                            <propertyref prefix="env"/>
                        </propertyset>
                </subant>
                </sequential>
        </macrodef>

        <macrodef name="installIvy">
            <sequential>
            <path id="ivy.classpath">
                <fileset dir="${omero.home}/lib/repository" includes="ivy*.jar"/>
                <fileset dir="${omero.home}/lib/repository" includes="jakarta-oro*.jar"/>
            </path>
            <taskdef resource="org/apache/ivy/ant/antlib.xml" uri="antlib:org.apache.ivy.ant" classpathref="ivy.classpath"/>
            <ivy:settings id="ivy.${ant.project.name}" file="${etc.dir}/ivysettings.xml"/>
            </sequential>
        </macrodef>

        <!--
           These classpaths are used by all components, and amount to only the deps.lib.dir
           directory within each component. That directory is configured using deps-retrieve,
           which "retrieves" the directories from the local directory. After that initial
           configuration, the build should be ivy-agnostic as far as possible.
        -->
        <macrodef name="defineClasspath">
           <sequential>
            <path id="omero.compile.classpath">
              <fileset dir="${deps.lib.dir}" />
            </path>
            <path id="omero.classpath">
              <path location="${classes.dir}" />
              <path location="${resrc.dir}" />
              <path location="${resrc.dest}" />
              <path refid="omero.compile.classpath" />
            </path>
            <path id="omero.test.classpath">
              <path refid="omero.classpath" />
            </path>
            </sequential>
        </macrodef>

        <macrodef name="defineVariables">
            <sequential>
                <condition property="test.with.fail">
                        <equals arg1="${multi.test.with.fail}" arg2="true"/>
                </condition>
                <condition property="test.skip">
                        <equals arg1="${multi.test.skip}" arg2="true"/>
                </condition>
                <condition property="emma.enabled">
                        <equals arg1="${multi.emma.enabled}" arg2="true"/>
                </condition>
                <condition property="generate.skip">
                        <equals arg1="${multi.generate.skip}" arg2="true"/>
                </condition>
                <condition property="checks.skip">
                        <equals arg1="${multi.checks.skip}" arg2="true"/>
                </condition>
            </sequential>
        </macrodef>

        <macrodef name="scons_py" description="Scons build tool installed under omero.home/target">
            <attribute name="dir" default="${basedir}"/>
            <attribute name="failonerror" default="true"/>
            <element name="args" implicit="yes"/>
            <sequential>
                <exec executable="python" dir="@{dir}" failonerror="@{failonerror}">
                    <env key="ICE_HOME" value="${ice.home}"/>
                    <arg value="${omero.home}/target/scons/scons.py"/>
                    <arg value="-Q"/>
                    <arg value="-j"/>
                    <arg value="${env.J}"/>
                    <args/>
                </exec>
            </sequential>
        </macrodef>

        <macrodef name="makeManifest">
            <attribute name="property"/>
            <sequential>
                <pathconvert property="mf.classpath" refid="omero.classpath" pathsep=" " dirsep="/">
                    <flattenmapper/>
                </pathconvert>
            </sequential>
        </macrodef>

        <!--
          Gather all compiled services together into a single
          services.jar.  Also, make all application jars available to the
          services.jar via the MANIFEST file *AND* add one additional
          (possibly non-extant) extensions.jar which can be created by 3rd
          parties and added to the lib dir (top-level) for runtime class
          lookups.

          services.jar is placed in the specified directory. Optionally, a
          manifest string can be specified. It defaults to the empty
          string, but a manifest can be generated via makeManifest if
          omero.classpath has been defined.
        -->
        <macrodef name="useServices">
            <attribute name="dir"/>
            <attribute name="manifest" default=""/>
            <sequential>
                <jar destfile="@{dir}/services.jar">
                    <include name="*"/>
                    <manifest>
                        <attribute name="Class-Path" value="@{manifest} extensions.jar"/>
                    </manifest>
                </jar>
                <jar destfile="@{dir}/extensions.jar">
                    <exclude name="*"/>
                    <manifest>
                        <attribute name="Class-Path" value=""/>
                    </manifest>
                </jar>
            </sequential>
        </macrodef>

        <!--
          The hard-wiring macro is used to allowcertain method interceptors to
          be hard-wired around method exception *before* any of the "soft"
          spring-wired interceptors (see resources/ome/services/services.xml)

          The values hard-wired in are the class names of subclasses of
          ome.logic.HardWireInterceptor with a no-arg constructor. This allows
          classes unknown to the server at compile time (like those under tools/)
          to become a part of a distribution.
        -->
        <macrodef name="hard-wire">
            <attribute name="fromdir" default="${src.dir}"/>
            <attribute name="todir" default="${src.dest}"/>
            <attribute name="file"/>
            <attribute name="token" default="@REPLACE@"/>
            <attribute name="value" default="${omero.hard-wired.interceptors}"/>
            <sequential>
		<mkdir dir="${target.dir}/hard-wiring"/>
                <copy todir="${target.dir}">
                    <fileset dir="@{fromdir}">
                        <include name="@{file}"/>
                    </fileset>
                </copy>
                <replace file="${target.dir}/@{file}">
                    <replacefilter token="@{token}" value="@{value}"/>
                </replace>
		<move todir="@{todir}">
		    <fileset dir="${target.dir}" includes="@{file}">
		        <different targetdir="@{todir}"/>
		    </fileset>
		</move>
            </sequential>
        </macrodef>

        <target name="help">
                <echo>
                        This build file is intended for import only.
                </echo>
        </target>

</project>
