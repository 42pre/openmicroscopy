 /*
 * org.openmicroscopy.shoola.agents.editor.model.UPEexport 
 *
 *------------------------------------------------------------------------------
 *  Copyright (C) 2006-2008 University of Dundee. All rights reserved.
 *
 *
 * 	This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *  
 *  You should have received a copy of the GNU General Public License along
 *  with this program; if not, write to the Free Software Foundation, Inc.,
 *  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 *------------------------------------------------------------------------------
 */
package org.openmicroscopy.shoola.agents.editor.model;

//Java imports

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.io.Writer;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;

import javax.swing.tree.DefaultMutableTreeNode;
import javax.swing.tree.TreeModel;
import javax.swing.tree.TreeNode;
import javax.swing.tree.TreePath;

//Third-party libraries

import net.n3.nanoxml.IXMLElement;
import net.n3.nanoxml.XMLElement;
import net.n3.nanoxml.XMLWriter;

//Application-internal dependencies

import org.openmicroscopy.shoola.agents.editor.model.params.AbstractParam;
import org.openmicroscopy.shoola.agents.editor.model.params.EnumParam;
import org.openmicroscopy.shoola.agents.editor.model.params.IParam;
import org.openmicroscopy.shoola.agents.editor.model.params.NumberParam;
import org.openmicroscopy.shoola.agents.editor.model.params.SingleParam;

/** 
 * This class is for exporting OMERO.editor files as "UPE" Universal Protocol 
 * Exchange XML files. 
 *
 * @author  William Moore &nbsp;&nbsp;&nbsp;&nbsp;
 * <a href="mailto:will@lifesci.dundee.ac.uk">will@lifesci.dundee.ac.uk</a>
 * @version 3.0
 * <small>
 * (<b>Internal version:</b> $Revision: $Date: $)
 * </small>
 * @since OME3.0
 */
public class UPEexport {
	
	public static final String  	XML_HEADER = 
							"<?xml version=\"1.0\" encoding=\"UTF-8\"?>";
	
	public static final String 		UPE_DTD = "<!DOCTYPE protocol-archive " +
		"PUBLIC \"-//Universal Protocol Exchange Format//DTD upe 1.0//EN\" " +
		"\"http://genome.tugraz.at/iLAP/upe/upe.dtd\">";

	public static final String 		UPE_STYLESHEET ="<?xml-stylesheet " +
		"href=\"http://genome.tugraz.at/iLAP/upe/upe2html.xsl\" " + 
		"type=\"text/xsl\"?>";
	
	/**
	 * The XML element that contains all the 'step' elements. 
	 * Steps are added by the recursive treeModel processing, to form a 
	 * 'flat' list of steps. 
	 */
	private IXMLElement 			steps;
	
	/**
	 * A Map of the steps that have been processed and output. This maps the
	 * tree-path of a field/step in the OMERO.editor treeModel to a path
	 * representation of UPE (e.g. 001/002). When a step element is processed,
	 * its UPE path can be generated by finding it's parent's UPE path from
	 * this map, and adding it's own index to the path. 
	 */
	private Map<TreePath, String>	ancestorSteps;
	
	
	/**
	 * A recursive method that traverses the treeModel, adding each node
	 * as a child 'step' to the {@link #steps} element. 
	 * Step element creation is handled by the {@link #createStepElement(TreeNode)} 
	 * method, but the addition of a UPE path is handled below. 
	 * 
	 * @param node			The root node of the tree
	 * @param element		The element corresponding to the node. 
	 */
	private void processSteps(TreeNode node) 
	{
		if (node == null) return;
		
		TreeNode childNode;
		IXMLElement step;
		for(int i=0; i<node.getChildCount(); i++) {
			childNode = node.getChildAt(i);
			
			// create step
			step = createStepElement(childNode);
			
			// identify parent's path
			DefaultMutableTreeNode dmTreeNode = (DefaultMutableTreeNode)childNode;
			TreePath newPath = new TreePath(dmTreeNode.getPath());
			
			TreePath parentPath = newPath.getParentPath();

			String parentID;
			String iD = "";
			int nodeIndex;		// parent's index of node (starts at 1)
			
			if (parentPath == null)	{}	// won't happen
			
			// if the parent is root, the path of this node is it's index
			else if (parentPath.getPathCount() == 1)	{
				nodeIndex = dmTreeNode.getParent().getIndex(dmTreeNode) + 1;
				iD = formatPathIndex(nodeIndex);	// convert to "001" format
				ancestorSteps.put(newPath, iD);
			}
			// otherwise, the path of this node is it's parent path + index
			else {
				parentID = ancestorSteps.get(parentPath);
				nodeIndex = dmTreeNode.getParent().getIndex(dmTreeNode) + 1;
				iD = parentID + "/" + formatPathIndex(nodeIndex);
				ancestorSteps.put(newPath, iD);
			}
			
			// set it's path. 
			addChildContent(step, "path", iD);
			
			// if it has children, then it is a STEP_GROUP
			if (childNode.getChildCount() == 0) {
				addChildContent(step, "step-type", "SINGLE_STEP");
			} else {
				addChildContent(step, "step-type", "STEP_GROUP");
			}
			
			// all steps are children of the steps element. 
			steps.addChild(step);
			
			// recursively process the tree rooted at childNode
			processSteps(childNode);
		}
	}
	
	/**
	 * Formats the index of a child step to "001" format. 
	 * 
	 * @param index		The index
	 * @return			The String in "002" format.
	 */
	private String formatPathIndex(int index) 
	{
		int stringLength = 3;
		String indexString = index + "";
		while (indexString.length() <= stringLength) {
			indexString = "0" + indexString;
		}
		return indexString;
	}
	
	/**
	 * Creates an {@link IXMLElement} from a {@link TreeNode}.
	 * Gets the {@link IField} object from the node, and uses it to add
	 * name and content elements to a new {@link IXMLElement};
	 * 
	 * @param treeNode		The node used to generate a new Element
	 * @return				A new Element, based on the node. 
	 */
	private IXMLElement createStepElement(TreeNode treeNode) 
	{
		// create element, add essential attributes
		IXMLElement step = new XMLElement("step");
		
		IField field = getFieldFromTreeNode(treeNode);
		if (field == null) return step;
	
		// name
		String name = field.getAttribute(Field.FIELD_NAME);
		if (name != null)
			addChildContent(step, "name", name);
		// description
		if (field.getContentCount() >0) {
			String desc = field.getContentAt(0).toString();
			addChildContent(step, "description", desc);
		}
		
		addChildContent(step, "deletable", "true");
		
		// add parameters
		int contentCount = field.getContentCount();
		
		IXMLElement params = new XMLElement("parameters");
		
		IFieldContent content;
		IXMLElement parameter;
		for (int i=0; i<contentCount; i++) {
			content = field.getContentAt(i);
			if (content instanceof IParam) {
				parameter = createParamElement((IParam)content);
				params.addChild(parameter);
			}
		}
		// if any parameters, add parameters element to step. 
		if (params.getChildrenCount() > 0) {
			step.addChild(params);
		}
		
		return step;
	}
	
	
	/**
	 * Handles the creation of an XML element for a parameter.
	 * If appropriate, the type of parameter will be NUMERIC or 
	 * ENUMERATION, with the associated additional attributes. Otherwise
	 * will be TEXT. No other types supported as yet. 
	 * 
	 * @param param			The parameter object 
	 * @return				A new XML Element that defines the parameter
	 */
	private IXMLElement createParamElement(IParam param) 
	{
		IXMLElement parameter = new XMLElement("parameter");
		
		// Add name, necessity, value and default-value, if not null
		String name = param.getAttribute(AbstractParam.PARAM_NAME);
		if (name != null)
			addChildContent(parameter, "name", name);
		
		addChildContent(parameter, "necessity", "OPTIONAL");
		
		String value = param.getAttribute(SingleParam.PARAM_VALUE);
		if (value != null)
			addChildContent(parameter, "value", value);
		
		String defaultValue = param.getAttribute(SingleParam.DEFAULT_VALUE);
		if (defaultValue != null)
			addChildContent(parameter, "default-value", defaultValue);
		
		// Depending on the type of parameter, set the param-type, 
		// and add any additional attributes. 
		if (param instanceof NumberParam) {
			addChildContent(parameter, "param-type", "NUMERIC");
			String units = param.getAttribute(NumberParam.PARAM_UNITS);
			if (units != null)
				addChildContent(parameter, "unit", units);
		} else 
		if (param instanceof EnumParam) {
			addChildContent(parameter, "param-type", "ENUMERATION");
			String enumOptions = param.getAttribute(EnumParam.ENUM_OPTIONS);
			if (enumOptions != null) {
				IXMLElement enumList = new XMLElement("enum-list");
				String[] options = enumOptions.split(",");
				for (int i=0; i<options.length; i++) {
					addChildContent(enumList, "enum", options[i].trim());
				}
				parameter.addChild(enumList);
			}
		} 
		else {
			// default type is TEXT
			addChildContent(parameter, "param-type", "TEXT");
		}
		
		return parameter;
	}
	
	/**
	 * Convenience method for adding child content to an XML element.
	 * String is added as text content of a new child element.
	 * 
	 * @param parent			The parent XML element
	 * @param childName			The name of the new Child element
	 * @param childContent		The text content of the new child element
	 */
	private static void addChildContent(IXMLElement parent, 
									String childName, String childContent) 
	{
		IXMLElement child = new XMLElement(childName);
		child.setContent(childContent);
		parent.addChild(child);
	}
	
	/**
	 * Handles the retrieval of the {@link IField} from a node of treeModel. 
	 * Returns null if the node is not a {@link DefaultMutableTreeNode} or
	 * the userObject in the node is not a {@link IField}.
	 * 
	 * @param treeNode		The node that contains the field.
	 * @return				see above 
	 */
	private static IField getFieldFromTreeNode(TreeNode treeNode) 
	{
		// if treeNode isn't a DefaultMutableTreeNode, return null
		if (treeNode == null) return null;
		if (! (treeNode instanceof DefaultMutableTreeNode)) return null;
		
		// get the userObject from the node. If it's a Field...
		DefaultMutableTreeNode dmNode = (DefaultMutableTreeNode)treeNode;
		Object userOb = dmNode.getUserObject();
		if (userOb instanceof IField) {
			IField field = (IField)userOb;
			return field;
		}
		return null;
	}

	/**
	 * Exports a UPE XML document created from the {@link TreeModel} to the
	 * {@link File} specified. 
	 * 
	 * @param treeModel			The OMERO.editor data model. 
	 * @param file				The XML file to export to. 
	 */
	public void export(TreeModel treeModel, File file) 
	{
		// start with the root of the XHTML document
		IXMLElement protocolArchive = new XMLElement("protocol-archive");
		
		// add archive info element
		IXMLElement archiveInfo = new XMLElement("archive-info");
		addChildContent(archiveInfo, "archive-version", "1.0");
		Date now = new Date();
		addChildContent(archiveInfo, "archive-date", now.getTime() + "");
		addChildContent(archiveInfo, "archive-creator", "OMERO.editor");
		addChildContent(archiveInfo, "archive-type", "PROTOCOL_ARCHIVE");
		protocolArchive.addChild(archiveInfo);
		
		// add protocol element, which contains info and steps 
		IXMLElement protocol = new XMLElement("protocol");
		protocolArchive.addChild(protocol);
		IXMLElement protocolInfo = new XMLElement("protocol-information");
		protocol.addChild(protocolInfo);
		
		// get the root of the data
		TreeNode root = (TreeNode)treeModel.getRoot();
		IField protocolRoot = getFieldFromTreeNode(root);
		
		// name
		String protName = protocolRoot.getAttribute(Field.FIELD_NAME);
		if ((protName != null) && (protName.length() >0)) {
			addChildContent(protocolInfo, "name", protName);
		}

		// description
		if (protocolRoot.getContentCount() >0) {
			String desc = protocolRoot.getContentAt(0).toString();
			addChildContent(protocolInfo, "description", desc);
		}
		// could add revision info if available
		// addChildContent(protocolInfo, "revision", "1");
		
		ancestorSteps = new HashMap<TreePath, String>();
		steps = new XMLElement("steps");
		protocol.addChild(steps);
		
		// recursively builds a tree of elements from the treeModel
		processSteps(root);
		
		Writer output;
		try {
			output = new FileWriter(file);
			output.write(XML_HEADER + "\n");
			output.write(UPE_STYLESHEET + "\n");
			output.write(UPE_DTD + "\n");
			XMLWriter xmlwriter = new XMLWriter(output);
			xmlwriter.write(protocolArchive, true);
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}
}
